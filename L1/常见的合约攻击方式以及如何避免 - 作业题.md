## 什么是重入攻击，它是如何在智能合约中执行的？

​	重入攻击是发生在智能合约未完成其所有内部状态更新完成之前，调用外部合约或发送以太币时，攻击者可以利用这个外部调用的机会重新进入原合约的函数，执行可能未考虑先前未完成的状态变化的操作。这种攻击可能导致资金被盗取或者逻辑被错误执行

## 如何防止智能合约中的重入攻击？

​	1、使用互斥锁确保合约不会并行调用

​	2、确保所有状态变更都在外部调用之前完成

​	3、使用transfer()、send()而不是底层的call(),因为前两个方法限制了可用的gas数量，防止了状态更改

## DAO 攻击是如何发生的，它与重入漏洞有什么关系？

​	DAO攻击发生在一个名为The DAO的智能合约，攻击者利用重入漏洞，通过反复调用取款函数，在更新用户余额之前多次提取资金，攻击者能够提前超出其原始份额的资金。这次攻击导致数百万美元的损失，并最终导致了以太坊的硬分叉。

## 什么是整数溢出和下溢，它们如何影响智能合约？

​	整数溢出和下溢是发生在进行数学运算时，计算结果超出了变量可以存储的最大值和最小值。

​	在智能合约中，这可以导致超出预期的行为，例如资金错误的增加或者减少。

## 如何在 Solidity 合约中防止整数溢出和下溢？

​	可以使用OpenZeepelin的SafeMath库来防止整数溢出和下溢，改库为所有数学运算提供安全的方法来确保运算安全

## 如何理解 Solidity 中的可见性关键字，并且它们的误用如何导致合约被攻击？

​	solidity中的可见性关键字包括：public、external、private、internel，它们定义了函数和变量可以被访问的范围。如果合约被错误的标记为了public或者external，就可能会被攻击者恶意调用，或在不合适的上下文中使用，导致资金损失或者状态被不当修改

## 什么是委托调用（`delegatecall`）和它的风险？

​	delegateCall是一种在solidity中允许一个合约以自己的存储环境执行另一个合约代码的功能。这种调用方式可以使得合约可以共享逻辑但保留独立的存储。

​	但是不正确使用，可能导致合约状态被恶意合约修改，因为delegatecall保留了合约的msg.sender和msg.value

## 什么是交易顺序依赖性，它如何被利用进行攻击？

​	交易顺序依赖性指的是 交易结果依赖于区块中交易的顺序。攻击者可以通过所谓的前置运行攻击，观察到挂起的交易，快速发送另一笔具有更高gas的交易，以确保交易优先于原始交易，从而利用这种依赖性盈利

## 在智能合约中如何安全地处理外部调用？

​	1、避免在状态更新前进行外部调用

​	2、总是检查外部调用的返回值

​	3、考虑实施模式，如检查-效果-交互模式，确保在进行任何外部交易前，先对所有状态更新和检查

## 如何利用以太坊的特性来增强智能合约的安全性？

​	利用以太坊的工具和模式，

​	1、使用事件日志来记录重要的状态变更，

​	2、利用函数修饰器来复用代码和安全检查，

​	3、利用库合约来减少重复代码和提高代码的安全性

​	4、采用最新的编程模式，如使用构造函数参数创建合约实例，避免中间件攻击

## 什么是智能合约中的拒绝服务（DOS）攻击？

​	拒绝服务攻击是通过使合约无法操作或执行其功能，来阻止用户访问智能合约的一种攻击手段。

​	例如，攻击者可能通过使合约消耗超过区块的gas限制来阻止合约功能的执行

## 描述一种可能导致智能合约 DOS 攻击的情况?

​	如果一个智能合约的功能依赖循环遍历一个  用户可以影响大小的数据结构（数组），攻击者可以通过填充该数据结构使合约功能耗尽所有gas，导致函数调用失败

## 智能合约中的“所有者操作”是什么意思？它如何成为安全漏洞？

​	在智能合约中，如果某些关键功能仅由所有者地址调用，并且如果所有者丢失访问权限或者变得不活跃，整个合约可能变得不可用。

​	这类设计导致合约依赖单一账户，增加了故障点

## Solidity 中使用 `block.timestamp` 可能导致哪些安全问题？

​	block.timestamp可以由矿工在一定范围内操控，若合约依赖时间戳来产生随机数，或者作为状态变化的触发条件，可能被矿工利用以影响合约

## 构造函数在 Solidity 中的命名与漏洞有何关联？

​	在solidity的0.4.22版本之前，构造函数需要与合约名称相同。如果构造函数与合约名称不匹配，它将变为普通函数，可能被外部调用，从而导致权限泄露

## 什么是未初始化的存储指针漏洞？它如何影响智能合约？

​	未初始化的存储指针可能指向随机存储位置，意外的覆盖重要的合约状态。

​	例如：可能导致合约的锁定状态被意外解除，从而功能被在不应当的时候触发

## 为什么在 Solidity 中不推荐使用 tx.origin 进行身份验证？

​	使用tx.origin进行身份验证容易受到钓鱼攻击，因为它返回调用链的最初发起者，如果合约用户被诱导与恶意合约交互，恶意合约可以在背后调用另一个合约，而tx.origin仍然显示用户地址，误导认证逻辑

##  Solidity 不支持浮点数或定点数的后果是什么？

​	意味着所有数值必须用整数表示，这可能导致精度问题，特别是在涉及到除法时。

​	如代币兑换或者金融计算 可能因为四舍五入导致资金损失

## 什么是“一次性地址”技术，它如何在以太坊上被利用？

​	一次性地址技术涉及构建能够有效签名事务的随机 r 和 s 值（ECDSA 组件），使得派生的以太坊地址被用作交易的发起者。这可以用于无需知道私钥的情况下，临时或匿名地管理资金。

## 描述如何在智能合约中防止未授权的修改或访问

​	合约实施访问控制模式，例如通过修饰器限制函数调用者的角色。

​	此外，考虑实现多重签名或基于时间的自动化解锁机制，以减少依赖单一账户或个体的风险。









